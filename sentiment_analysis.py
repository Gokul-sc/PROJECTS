# -*- coding: utf-8 -*-
"""Sentiment_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s0cIJ-d3kNy7MNvHf4P0dzYmuH9IDOf6
"""

!pip install datasets

import torch

device="cuda" if torch.cuda.is_available() else "cpu"

from datasets import load_dataset

dataset=load_dataset("imdb")



# dataset

train_reviews=dataset["train"]["text"]
train_labels=dataset["train"]["label"]
test_reviews=dataset["test"]["text"]
test_labels=dataset["test"]["label"]

train_reviews[0]

train_labels[0]

import pandas as pd
df=pd.DataFrame(train_reviews,columns=["text"])
df["label"]=train_labels
df["label"].value_counts()

# !pip install sentence-transformers

from sentence_transformers import SentenceTransformer

model=SentenceTransformer('all-MiniLM-L6-v2')
train_embeddings=model.encode(train_reviews,show_progress_bar=True)
test_embeddings=model.encode(test_reviews,show_progress_bar=True)

"""## **TensorDataset is used to bundle th independant and the dependant variables as one dataset of tpe tensor. DataLoader is used for batch processing**"""

import torch
from torch.utils.data import TensorDataset, DataLoader

# !nvidia-smi

X_train=torch.tensor(train_embeddings,dtype=torch.float32)
Y_train=torch.tensor(train_labels,dtype=torch.long)
X_test=torch.tensor(test_embeddings,dtype=torch.float32)
Y_test=torch.tensor(test_labels,dtype=torch.long)

train_dataset=TensorDataset(X_train,Y_train)
test_dataset=TensorDataset(X_test,Y_test)

train_loader=DataLoader(train_dataset,batch_size=32,shuffle=True)
test_loader=DataLoader(test_dataset,batch_size=32,shuffle=False)

"""# **Neural Nework with 2 HIDDEN LAYERS EACH WITH RELU ACTIVATION FUNCTION**"""

from torch import nn

class Sentiment(nn.Module):
  def __init__(self):
    super().__init__()
    self.layer1=nn.Linear(384,128)
    self.layer2=nn.Linear(128,64)
    self.layer3=nn.Linear(64,1)
    self.relu=nn.ReLU()
  def forward(self,x):
    return self.layer3(self.relu(self.layer2(self.relu(self.layer1(x)))))

"""# **DEVICE AGNOSTIC CODE**"""

device='cuda' if torch.cuda.is_available() else 'cpu'
torch.manual_seed(42)
model=Sentiment()
# model.state_dict()
model.to(device)

"""# **LOSS FUNCTION**"""

Loss=nn.BCEWithLogitsLoss()
Optimizer=torch.optim.Adam(model.parameters(),lr=0.001,weight_decay=0.01)

# for x,y in test_loader:
#   print(y.size())

"""# **TRAINING**"""

epochs=100
for epoch in range(epochs):
  model.train()
  for x,y in train_loader:
    x, y = x.to(device), y.to(device)
    pred=model(x)
    # print(pred.shape)
    loss=Loss(pred.squeeze(),y.float())
    Optimizer.zero_grad()
    loss.backward()
    Optimizer.step()

  print(f"Epoch: {epoch+1}, Loss: {loss.item()}")

"""# **EVALUATION**"""

model.eval()
  total=0
  correct=0
  with torch.inference_mode():
    for x,y in test_loader:
      x, y = x.to(device), y.to(device)
      pred=model(x)
      # print(pred.shape)

      loss=Loss(pred.squeeze(),y.float())
      prob=torch.round(torch.sigmoid(pred))
      # predi=torch.where(prob>0.5,1,0)
      # print(pred)
      total+=y.size(0)
      correct += (prob.squeeze() == y).sum().item()

accuracy=correct/total

print(f"Accuracy: {accuracy}")
prob==y

"""# **Saving Model Parameters**"""

from pathlib import Path
MODEL_PATH=Path("models")
MODEL_PATH.mkdir(parents=True,exist_ok=True)
MODEL_NAME="Sentiment_Analysis.pth"
MODEL_SAVE_LOCATION=MODEL_PATH/MODEL_NAME
MODEL_SAVE_LOCATION

torch.save(obj=model.state_dict(),f=MODEL_SAVE_LOCATION)

user=input("Enter the review: ")

model=SentenceTransformer('all-MiniLM-L6-v2')
trains_embeddings=model.encode(user,show_progress_bar=True)

user=torch.tensor(trains_embeddings,dtype=torch.float32)
Y_train=torch.tensor(train_labels,dtype=torch.long)

model2=Sentiment()

model2.load_state_dict(torch.load(f=MODEL_SAVE_LOCATION))

model2.eval()
with torch.inference_mode():
  pred=model2(user)
  pred_labels = torch.round(torch.sigmoid(pred))
  print(pred)
  print(pred_labels)
if pred_labels.item()==0.0:
  print("Negative Statement")
else:
  print("Positive Statement")

